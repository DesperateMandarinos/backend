# -*- coding: utf-8 -*-
"""Copia de 4_Reto_Modelo_RandomForest_Final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VjmaA4rDSLyNMimtfu_SaYPMnXc0-4tD

#House Prices: Limpieza de las bases de datos

##Librerias
"""

#libreria
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error

"""##Carga de las bases de datos"""

#load database
df_train = pd.read_csv("backend/house-prices-advanced-regression-techniques/train.csv")
df_train.head()

df_test = pd.read_csv("backend/house-prices-advanced-regression-techniques/train.csv")

#load database
df_test = pd.read_csv("backend/house-prices-advanced-regression-techniques/test.csv")
df_test.head()

#load database
df = pd.read_csv("backend/house-prices-advanced-regression-techniques/sample_submission.csv")
df.head()

"""##Diccionario

| Variable | Tipo | Categoría |
|----------|----------|----------|
| ID    | Int   | Numérico discreto   |
| MSSubClass    | Int   | Numérico discreto   |
| MSZoning    | Object   | Categórico Nominal   |
| LotFrontage   | Float   | Numérico Continuo   |
| LotArea    | Int   | Numérico discreto   |
| Street    | Object   | Categórico Nominal   |
| Alley    | Object   | Categórico Nominal   |
| LotShape    | Object   | Categórico Nominal   |
| LandCountour    | Object   | Categórico Nominal   |
| Utilities   | Object   | Categórico Nominal   |
| LotConfig    | Object   | Categórico Nominal   |
| LandSlope    | Object   | Categórico Nominal   |
| Neighborhood    | Object   | Categórico Nominal   |
| Condition1    | Object   | Categórico Nominal   |
| Condition2    | Object   | Categórico Nominal   |
| BldgType    | Object   | Categórico Nominal   |
| HouseStyle   | Object   | Categórico Nominal   |
| OverallQual    | Int   | Numérico Discreto   |
| OverallCond    | Int   | Numérico Discreto   |
| YearBuilt    | Int   | Numérico Discreto   |
| YearRemodAdd    | Int   | Numérico Discreto   |
| RoofStyle    | Object   | Categórico Nominal   |
| RoofMalt    | Object   | Categórico Nominal   |
| Exterior1st    | Object   | Categórico Nominal   |
| Exterior2nd    | Object   | Categórico Nominal   |
| MasVnrType   | Object   | Categórico Nominal   |
| MasVnrArea    | Float   | Numérico Continuo   |
| ExterQual    | Object   | Categórico Nominal   |
| ExterCond    | Object   | Categórico Nominal   |
| Foundation    | Object   | Categórico Nominal   |
| BsmtQual    | Object   | Categórico Ordinal   |
| BsmtCond    | Object   | Categórico Ordinal  |
| BsmtExposure   | Object   | Categórico Ordinal   |
| BsmtFinType1    | Object   | Categórico Ordinal  |
| BsmtFinSF1    | Int   | Numérico Discreto   |
| BsmtFinType2    | Object   | Categórico Ordinal   |
| BsmtFinSF2    | int   | Numérico Discreto   |
| BsmtUnfSF   | int   | Numérico Discreto |
| TotalBsmtSF    | int   | Numérico Discreto   |
| Heating    | Object   | Categórico Nominal   |
| HeatingQC    | Object   | Categórico Ordinal    |
| CentralAir    | Object   | Categórico Nominal    |
| Electrical    | Object   | Categórico Nominal   |
| 1stFlrSF    | int   | Numérico Discreto   |
| 2ndFlrSF    | int   | Numérico Discreto   |
| LowQualFinSF   | int   | Numérico Discreto   |
| GrLivArea    | int   | Numérico Discreto   |
| BsmtFullBath    | int   | Numérico Discreto   |
| BsmtHalfBath   | int   | Numérico Discreto   |
| FullBath    | int   | Numérico Discreto   |
| HalfBath    | int   | Numérico Discreto   |
| BedroomAbvGr   | int   | Numérico Discreto   |
| KitchenAbvGr    | int   | Numérico Discreto   |
| KitchenQual    | object   | Categórico Ordinal   |
| TotRmsAbvGrd   | int   | Numérico Discreto   |
| Functional    | object   | Categórico Nominal   |
| Fireplaces    | int   | Numérico Discreto   |
| FireplaceQu   | object   | Categórico Ordinal   |
| GarageType    | object   | Categórico Nominal   |
| GarageYrBlt    | float   | Numérico Continuo   |
| GarageFinish   | object   | Categórico Nominal   |
| GarageCars    | int   | Numérico Discreto    |
| GarageArea    | int   | Numérico Discreto   |
| GarageQual   | object   | Categórico Ordinal   |
| GarageCond   | object   | Categórico Ordinal   |
| PavedDrive    | object   | Categórico Nominal   |
| WoodDeckSF   | int   | Numérico Discreto   |
| OpenPorchSF   | int   | Numérico Discreto   |
| EnclosedPorch   | int   | Numérico Discreto   |
| 3SsnPorch   | int   | Numérico Discreto   |
| ScreenPorch   | int   | Numérico Discreto   |
| PoolArea   | int   | Numérico Discreto   |
| PoolQC   | object   | Categórico Ordinal   |
| Fence   | object   | Categórico Ordinal   |
| MiscFeature    | object   | Categórico Nominal   |
| MiscVal   | int   | Numérico Discreto   |
| MoSold   | int   | Numérico Discreto   |
| YrSold   | int   | Numérico Discreto   |
| SaleType   | object   | Categórico Nominal   |
| SaleCondition    | object   | Categórico Nominal   |
| SalePrice   | int   | Numérico Discreto   |

##Limpieza: Train

###Información

Revisando previamente nuestra base de datos y analizando el diccionario que se proporciona en la competencia de kaggle identificamos que en varias de las categorías hay valores NA, los cuales, en su mayoría pertenecen a NA: No hay ese elemento en la casa en cuestión, por lo que se presenta la siguiente tabla de las variables con NA values y se identifican si corresponden a la categoría o son valores nulos.

| Variable | NA/Null | Cantidad de NA |
|----------|----------|----------|
| LotFrontage   | Null   | 259   |
| Alley    | NA: No access   | 1369   |
| MasVnrType   | Null   | 8   |
| MasVnrArea    | Null   | 8  |
| BsmtQual    | NA: No Bsmt | 37 |
| BsmtCond    | NA: No Bsmt | 37 |
| BsmtExposure | NA: No Bsmt | 38 |
| BsmtFinType1 | NA: No Bsmt   | 37 |
| BsmtFinType2   | NA: No Bsmt  | 38|
| Electrical    | Null   | 1   |
| FireplaceQu | NA: No Fireplace|690|
| GarageType | NA: No Garage  | 81 |
| GarageYrBlt  | NA: No Garage | 81 |
| GarageFinish | NA: No Garage | 81 |
| GarageQual   | NA: No Garage | 81 |
| GarageCond   | NA: No Garage | 81 |
| PoolQC  | NA: No Pool | 1453 |
| Fence   | NA: No Fence | 1179 |
| MiscFeature | NA: No Misc | 1406 |
| MiscVal   | Null   | 2  |

Por lo anterior, al ser menos los datos NULL, se remplazarán los valores NA de la base de datos por un str "NA_Valor" con el objetivo de que no se identifiquen como Null y así solo poder procesar los correspondientes.
"""

#replace de los NA
df_train = df_train.replace([np.nan], ["NA_Valor"])

#Dimensiones de la base de datos
df_train.shape

#pd.set_option('display.max_rows', None)

#Tipos de variables en el dataset
df_train.dtypes

"""Tras el replace de los NA por NA_Valores y segun el diccionario previo, la conversión afectó a las siguientes variables, las cuales posteriormente se convertiran nuevamente al tipo de variable que les corresponde.

| Variable | Tipo Actual| Tipo Real |
|----------|----------|----------|
| LotFrontage | Object   | Float  |
| MasVnrArea    | Object   |  Float |

"""

#valores nulos
df_train.isna().sum()

"""Como se observa, no contamos con ningún valor nulo en la base de datos gracias al replace que se realizó."""

#valores duplicados en los registros de la base de datos
duplicates = df_train.duplicated(subset=None).to_numpy()
len(duplicates)

#ciclo que suma 1 si no hay valores duplicados en cada entrada del df
cont=0
for i in range (0,1460):
  if duplicates[i]==False:
    cont +=1
print(cont)

#array con el nombre de las variables
train_columns = df_train.columns.to_numpy()
len(train_columns)

"""###Conversión tipo de variables

Se realizará la conversión de las siguientes variables para posteriormente tratar sus datos nulos.

| Variable | Tipo Actual| Tipo Real |
|----------|----------|----------|
| LotFrontage | Object   | Float  |
| MasVnrArea    | Object   |  Float |

"""

df_train['LotFrontage'] = pd.to_numeric(df_train['LotFrontage'], errors='coerce')
df_train['MasVnrArea'] = pd.to_numeric(df_train['MasVnrArea'], errors='coerce')

print(df_train['LotFrontage'].dtypes)
print(df_train['MasVnrArea'].dtypes)

"""###Tratamiento de Datos Nulos

Las variables con datos nulos a tratar son las siguientes:

| Variable | Cantidad de Null| Tratamiento |
|----------|----------|----------|
| LotFrontage | 259   | Mediana |
| MasVnrType    | 8   | Eliminar |
| MasVnrArea    | 8   | Eliminar |
| Electrical    | 1   | Eliminar |
| MiscVal   | 2 | Eliminar |

De MasVnrType son los mismos 8 registros que MasVnrArea.

MiscVal se eliminaran los registros 874 y 1202 ya que no hay un MiscFeature en esas entradas.
"""

df_train['LotFrontage'].isna().sum()

cont=0
for i in range (0,1460):
  if df_train["MasVnrType"].iloc[i]=="NA_Valor":
    cont +=1
print(cont)

df_train['MasVnrArea'].isna().sum()

cont=0
for i in range (0,1460):
  if df_train["Electrical"].iloc[i]=="NA_Valor":
    cont +=1
print(cont)

df_train['MiscVal'].iloc[874]

df_train['MiscVal'].iloc[1201]

df_train.dropna(subset=["MasVnrArea"], inplace=True)

df_train['MasVnrArea'].isna().sum()

cont=0
for i in range (0,1452):
  if df_train["MasVnrType"].iloc[i]=="NA_Valor":
    cont +=1
print(cont)

cont=0
for i in range (0,1452):
  if df_train["Electrical"].iloc[i]=="NA_Valor":
    cont +=1
print(cont)

df_train['LotFrontage'].isna().sum()

df_train['MiscVal'].iloc[874]

df_train['MiscVal'].iloc[1201]

df_train = df_train.drop([874,1201], axis=0)

df_train.shape

filas_filtradas = df_train[df_train['Electrical'] == "NA_Valor"]
filas_filtradas

df_train = df_train.drop([1379], axis=0)

df_train.shape

df_train['LotFrontage']=df_train['LotFrontage'].fillna(df_train['LotFrontage'].median())

df_train['LotFrontage'].isna().sum()

"""###OneHotEncoder
Conversión de valores categóricos a numéricos

####Replace: Variables Ordinales
"""

reemplazo = {'BsmtQual': {"Ex": 5, "Gd": 4, "TA": 3, "Fa":2, "Po": 1, "NA_Valor":0},
             'BsmtCond': {"Ex": 5, "Gd": 4, "TA": 3, "Fa":2, "Po": 1, "NA_Valor":0},
             'FireplaceQu': {"Ex": 5, "Gd": 4, "TA": 3, "Fa":2, "Po": 1, "NA_Valor":0},
             'GarageQual': {"Ex": 5, "Gd": 4, "TA": 3, "Fa":2, "Po": 1, "NA_Valor":0},
             'GarageCond': {"Ex": 5, "Gd": 4, "TA": 3, "Fa":2, "Po": 1, "NA_Valor":0},
             'PoolQC': {"Ex": 5, "Gd": 4, "TA": 3, "Fa":2, "Po": 1, "NA_Valor":0}}

# Aplicar el reemplazo a las columnas especificadas
df_train.replace(reemplazo, inplace=True)

reemplazo = {'ExterQual': {"Ex": 5, "Gd": 4, "TA": 3, "Fa":2, "Po": 1},
             'ExterCond': {"Ex": 5, "Gd": 4, "TA": 3, "Fa":2, "Po": 1},
             'HeatingQC': {"Ex": 5, "Gd": 4, "TA": 3, "Fa":2, "Po": 1},
             'KitchenQual': {"Ex": 5, "Gd": 4, "TA": 3, "Fa":2, "Po": 1}}

# Aplicar el reemplazo a las columnas especificadas
df_train.replace(reemplazo, inplace=True)

reemplazo = {'LotShape': {"Reg": 4, "IR1": 3, "IR2": 2, "IR3":1},
             'Utilities': {"AllPub": 4, "NoSewr": 3, "NoSeWa":2, "ELO": 1},
             'LandSlope': {"Gtl": 3, "Mod":2, "Sev": 1},
             'BsmtFinType1': {"GLQ": 6, "ALQ": 5, "BLQ": 4, "Rec": 3, "LwQ":2, "Unf": 1,"NA_Valor":0},
             'BsmtFinType2': {"GLQ": 6, "ALQ": 5, "BLQ": 4, "Rec": 3, "LwQ":2, "Unf": 1,"NA_Valor":0},
             'BsmtExposure': {"Gd": 4, "Av": 3, "Mn":2, "No": 1, "NA_Valor":0},
             'GarageFinish': {"Fin": 3, "RFn":2, "Unf": 1, "NA_Valor":0},
             'PavedDrive': {"Y":2, "P": 1, "N":0},
             'Fence': {"GdPrv": 4, "MnPrv": 3, "GdWo":2, "MnWw": 1, "NA_Valor":0},
             'Functional': {"Typ": 8, "Min1": 7, "Min2": 6, "Mod": 5, "Maj1": 4, "Maj2": 3, "Sev":2, "Sal": 1},
             'CentralAir': {"Y":1, "N":0},
             "GarageYrBlt": {"NA_Valor":0}}

# Aplicar el reemplazo a las columnas especificadas
df_train.replace(reemplazo, inplace=True)

df_train['GarageYrBlt'] = df_train['GarageYrBlt'].astype('Int64')

df_train.dtypes

df_train.drop(["Id"], axis=1, inplace=True)

"""###Matriz de correlaciones (selección de variables numéricas)"""

numericas = df_train.select_dtypes(include=['int64','float64'])

sns.set(rc = {'figure.figsize':(100,80)})
sns.heatmap(numericas.corr(), annot=True)

correlations = df_train.corr()
correlation_with_target = correlations['SalePrice'].abs()
threshold = 0.4  # Establece un umbral de correlación deseado
relevant_features = correlation_with_target[correlation_with_target >= threshold]

selected_features = relevant_features.index.tolist()

# Crear un nuevo DataFrame con solo las características seleccionadas
df_selected_features = df_train[selected_features]

df_selected_features

df_selected_features.shape

df_selected_features.columns.to_numpy()

"""####Dummy Variables: Variables Nominales (Selección y tratamiento)"""

categoricas = df_train.select_dtypes(include=["object"])
categoricas = categoricas.columns.to_numpy()
categoricas

# Crear un gráfico de regresión categórica para cada variable categórica
for categoria in categoricas:
    plt.figure(figsize=(8, 6))  # Ajusta el tamaño de la figura
    sns.stripplot(x=df_train[categoria], y=df_train["SalePrice"], data=df_train, jitter=True)
    sns.pointplot(x=df_train[categoria], y=df_train["SalePrice"], data=df_train, ci=None, color='red')
    plt.xlabel(categoria)  # Etiqueta del eje x
    plt.ylabel('SalePrice')  # Etiqueta del eje y
    plt.title(f'Gráfico de Regresión Categórica para {categoria}')  # Título del gráfico
    plt.show()  # Mostrar el gráfico

df_prueba=df_train.drop(["Street","Alley","LandContour","LotConfig","Condition1","Condition2","RoofStyle","RoofMatl","Heating","Electrical","MiscFeature"], axis=1)
df_prueba.head()

categoricas = df_prueba.select_dtypes(include=["object"])
categoricas = categoricas.columns.to_numpy()
categoricas

dummies = [df_prueba]

for columna in categoricas:
    df_codificado = pd.get_dummies(df_prueba[columna], prefix=columna)
    dummies.append(df_codificado)

# Combinar los DataFrames codificados en uno solo
df_prueba = pd.concat(dummies, axis=1)
df_prueba.drop(categoricas, axis=1, inplace=True)

df_prueba=df_prueba.select_dtypes(include=['uint8'])
df_prueba.dtypes

df_train=pd.concat([df_prueba, df_selected_features], axis=1)
df_train.shape

"""#Limpieza del Test"""


#replace de los NA
df_test = df_test.replace([np.nan], ["NA_Valor"])

df_test['GarageArea'].dtype

df_test['GarageCars'].dtype

df_test['KitchenQual'].dtype

df_test['TotalBsmtSF'].dtype

df_test['LotFrontage'].dtype

df_test['LotFrontage'] = pd.to_numeric(df_test['LotFrontage'], errors='coerce')
df_test['MasVnrArea'] = pd.to_numeric(df_test['MasVnrArea'], errors='coerce')
df_test['GarageArea'] = pd.to_numeric(df_test['GarageArea'], errors='coerce')
df_test['GarageCars'] = pd.to_numeric(df_test['GarageCars'], errors='coerce')
df_test['TotalBsmtSF'] = pd.to_numeric(df_test['TotalBsmtSF'], errors='coerce')

df_test['GarageArea'] = df_test['GarageArea'].astype('Int64')
df_test['GarageCars'] = df_test['GarageCars'].astype('Int64')
df_test['TotalBsmtSF'] = df_test['TotalBsmtSF'].astype('Int64')

reemplazo = {'BsmtQual': {"Ex": 5, "Gd": 4, "TA": 3, "Fa":2, "Po": 1, "NA_Valor":0},
             'BsmtCond': {"Ex": 5, "Gd": 4, "TA": 3, "Fa":2, "Po": 1, "NA_Valor":0},
             'FireplaceQu': {"Ex": 5, "Gd": 4, "TA": 3, "Fa":2, "Po": 1, "NA_Valor":0},
             'GarageQual': {"Ex": 5, "Gd": 4, "TA": 3, "Fa":2, "Po": 1, "NA_Valor":0},
             'GarageCond': {"Ex": 5, "Gd": 4, "TA": 3, "Fa":2, "Po": 1, "NA_Valor":0},
             'PoolQC': {"Ex": 5, "Gd": 4, "TA": 3, "Fa":2, "Po": 1, "NA_Valor":0}}

# Aplicar el reemplazo a las columnas especificadas
df_test.replace(reemplazo, inplace=True)

reemplazo = {'ExterQual': {"Ex": 5, "Gd": 4, "TA": 3, "Fa":2, "Po": 1},
             'ExterCond': {"Ex": 5, "Gd": 4, "TA": 3, "Fa":2, "Po": 1},
             'HeatingQC': {"Ex": 5, "Gd": 4, "TA": 3, "Fa":2, "Po": 1},
             'KitchenQual': {"Ex": 5, "Gd": 4, "TA": 3, "Fa":2, "Po": 1}}

# Aplicar el reemplazo a las columnas especificadas
df_test.replace(reemplazo, inplace=True)

reemplazo = {'LotShape': {"Reg": 4, "IR1": 3, "IR2": 2, "IR3":1},
             'Utilities': {"AllPub": 4, "NoSewr": 3, "NoSeWa":2, "ELO": 1},
             'LandSlope': {"Gtl": 3, "Mod":2, "Sev": 1},
             'BsmtFinType1': {"GLQ": 6, "ALQ": 5, "BLQ": 4, "Rec": 3, "LwQ":2, "Unf": 1,"NA_Valor":0},
             'BsmtFinType2': {"GLQ": 6, "ALQ": 5, "BLQ": 4, "Rec": 3, "LwQ":2, "Unf": 1,"NA_Valor":0},
             'BsmtExposure': {"Gd": 4, "Av": 3, "Mn":2, "No": 1, "NA_Valor":0},
             'GarageFinish': {"Fin": 3, "RFn":2, "Unf": 1, "NA_Valor":0},
             'PavedDrive': {"Y":2, "P": 1, "N":0},
             'Fence': {"GdPrv": 4, "MnPrv": 3, "GdWo":2, "MnWw": 1, "NA_Valor":0},
             'Functional': {"Typ": 8, "Min1": 7, "Min2": 6, "Mod": 5, "Maj1": 4, "Maj2": 3, "Sev":2, "Sal": 1},
             'CentralAir': {"Y":1, "N":0},
             "GarageYrBlt": {"NA_Valor":0}}

# Aplicar el reemplazo a las columnas especificadas
df_test.replace(reemplazo, inplace=True)

df_test['GarageYrBlt'] = df_test['GarageYrBlt'].astype('Int64')

df_test['KitchenQual'] = pd.to_numeric(df_test['KitchenQual'], errors='coerce')
df_test['KitchenQual'] = df_test['KitchenQual'].astype('Int64')

df_test['KitchenQual'].dtype

categoricas = df_test.select_dtypes(include=["object"])
categoricas = categoricas.columns.to_numpy()
categoricas

df_test.shape

df.shape

dummies = [df_test]

for columna in categoricas:
    df_codificado = pd.get_dummies(df_test[columna], prefix=columna)
    dummies.append(df_codificado)

# Combinar los DataFrames codificados en uno solo
df_test = pd.concat(dummies, axis=1)
df_test.drop(categoricas, axis=1, inplace=True)

df_test.shape

train_comparativa=df_train.columns.to_numpy()

columnas_comunes = df_train.columns.intersection(df_test.columns)

df_test = df_test[columnas_comunes]
df_test.shape

comparativa=np.setdiff1d(train_comparativa,columnas_comunes)
print(comparativa)

y_train = df_train["SalePrice"]

columnas_comunes = df_test.columns.intersection(df_train.columns)

df_train = df_train[columnas_comunes]
df_train.shape

"""#Separación de datos"""

#definimos las variables que tendremos en X y en y (variable a predecir)
X = df_train #eliminamos la columna Survived
y = pd.DataFrame(y_train) #mantenemos solo la columna Survived

from sklearn.model_selection import train_test_split

#haciendo uso del train_test_split con un 30% para test y 70% para train, separamos nuestro df
train_data, test_data = train_test_split(df_train, test_size=0.3, random_state=42)
#damos una semilla aleatoria, esta se puede cambiar pero alteraría los resultados del modelo en cada ocasión.

X_train = X.values
y_train = y.values
X_test = X.values
y_test = y.values

"""#Aplicación del Modelo"""

# Crear una instancia del modelo de regresión de Random Forest
rf_regressor = RandomForestRegressor(n_estimators=100, random_state=42)

# Entrenar el modelo en los datos de entrenamiento
rf_regressor.fit(X_train, y_train)

# Realizar predicciones en el conjunto de prueba
y_pred = rf_regressor.predict(X_test)

# Evaluar el rendimiento del modelo
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print(f"Mean Squared Error: {mse}")
print(f"R-squared: {r2}")

from sklearn.utils.parallel import joblib

joblib.dump(rf_regressor, 'dt1.joblib')